{"pages":[],"posts":[{"title":"函数形参定义习惯","text":"函数形参定义习惯[TOC]整理一下左值、右值、左值引用、右值引用、移动、转发的概念，以及使用它们的一般情况。 概念左值、右值，很直接地，等号的左边是左值，等号的右边是右值。更具体点，个人认为，如果你能够通过一个符号去找到一个对象（这里的对象不是oop中的对象，而是类似内存块中值的具体部分），那么这个符号是一个左值。放到cpu底层来看，就是左值是一个内存地址值，通过左值可以获得变量值，即cpu通过地址值来进行寻址后，找到对应的内存块，这个内存块中的值则是右值。所以就能够解释，T &amp;&amp;a 变量a是左值，尽管它有个右值引用的类型，右值引用类型的意思是a指向的内容是一个右值。 引用代表着别名，左值引用是左值的别名，右值引用则是右值的别名。如果说左值引用是为了消灭指针（事实上并没有消灭，其实左值引用还是有有别的用处的，但是我忘了，好像是对模板编程有好处），为什么c++11要整一个右值引用出来？ 答案是移动语义，个人的理解是（不一定对哈），编译器只有在遇到右值或者右值引用的时候，才会去找对应的移动构造函数，这样就可以减少消耗了，找不到则用拷贝构造。所以右值引用只是用来提示编译器，赋值的时候给我整移动构造，别拷贝了（没错，就是这么蛋疼）。 记住std::move做什么和不做什么很重要。它只进行转换，不移动任何东西。移动的事情是移动构造函数做的。对一个对象使用std::move就是告诉编译器，这个对象很适合被移动。所以这就是为什么std::move叫现在的名字：更容易指定可以被移动的对象。 best practice看到这里可能有人会说：“啊，别整那些没用的，我不听，你就说实际情况下该怎么用吧” 个人理解，我在定义函数形参时只用以下几种：值传递、const 引用、指针、右值引用、通用引用 值传递像int、double这类的基本类型的就值传递吧，没啥好说的。 如果是形参是类的话，以下是适用的情形： 123456789101112131415void Fun(std::string s); // 函数逻辑中需要拥有形参所有权的情况下// 对于移动成本低且总是被拷贝的可拷贝形参，可以按值传递然后move，// 按值传递效率基本与按引用传递效率一致（按值传递多了一次移动操作）// 这样易于实现，还生成更少的目标代码class Server { public: Server(std::string s) : my_str_(std::move(s)) {} private: std::string my_str_;};std::string text(&quot;hhh&quot;);Server(text); // 传左值消耗：一次拷贝，一次移动Server(&quot;hello&quot;); // 传右值消耗：两次移动 这个最简单，如果一个函数需要拥有形参的所有权（比如你想修改形参，但是不想改到函数外的实参），就直接用这种形式，进行一次值传递。 额外地，在构造函数上，会经常想用std::move来移动形参变量到类成员变量上，避免二次拷贝，这种情况下，函数的形参也用值传递，数据成员赋值时再用std::move。这种情况下函数形参不要定义成const std::string s，因为std::move(const string s)得到的是一个const的string右值，最后会变成调用到string的拷贝构造函数。要知道从一个对象中移动出某个值通常代表着修改该对象，语言不允许const对象被传递给可以修改他们的函数（例如移动构造函数），所以要用std::move移动某个对象，则不能定义成const。 更低消耗的形参拷贝方式那么有人会说，可不可以函数形参分别是const引用和右值引用，然后类成员变量拷贝const引用的值或者移动右值引用。答案是可以，甚至消耗更小。但是个人习惯只有在移动消耗不可接受的情况下才会使用，毕竟要维护两个重载函数，并且维护性不好。 123456789101112class Server { public: Server(const std::string &amp;s) : my_str_(s) {} Server(std::string &amp;&amp;s) : my_str(std::move(s)) {} private: std::string my_str_;};std::string text(&quot;hhh&quot;);Server(text); // 传左值消耗：一次拷贝Server(&quot;hello&quot;); // 传右值消耗：一次移动 其实这里还有一种写法，通用引用，个人习惯是只有模板编程才会用通用引用。 const引用引用只使用const引用 1234// 只读变量的情况下使用const引用，或者是需要最低消耗地拷贝函数形参的情况下使用（参考）。void Fun(const std::string &amp;s);Server(const Server &amp;s) {} // 拷贝构造函数中使用Server &amp;operator=(const Server &amp;s) {} //拷贝赋值函数中使用 在编译器的实现下，其实左值引用和指针其实底层的汇编是一样的，都是指针（或者说内存地址）。 我个人的习惯是，如果是传递引用的话只使用 const引用，不使用非const的引用，把引用的作用限制在避免参数拷贝的开销上。然后把改变变量内容的任务交给指针。 原因在于在调用函数时引用被伪装成与值传递相同的形式，f(a, b) 这样的形式你其实一眼看不出传的是值还是引用，这容易引起误解，以为这是传值，从而认为该调用不会修改变量的值。而指针就不存在这个问题，一个明确的符号显式的表明了该对象可能会被修改 f(&amp;a, &amp;b) 这样的格式是一个明显的信号，不会造成误解。至于const引用则与常量基本等价，所以认为他是值还是引用都没关系。 至于空指针的问题，你的设计逻辑需要判断就判断，如果本身不允许为空就没必要判断。原因在于空指针无非就是运行期间程序崩溃，而把空指针传给引用依然是运行期间程序崩溃。两者其实没有区别，只不过一个崩溃在函数外一个崩溃在函数内而已。如果你知道为什么会出现空指针，当然要判断，如果你自己都不知道为什么这里会空，崩溃才是最好办法。因为你没法把一个处于未知状态的程序拉回正常，重启服务才是最干脆的。 右值引用123void Fun(string &amp;&amp;s); // 需要最低消耗地拷贝函数形参的情况下使用Server(Server &amp;&amp;s) {} // 移动构造函数的情况中使用Server &amp;operator=(Server &amp;&amp;s) {} // 移动赋值函数中使用 通用引用传左值时，通用引用是左值引用，传右值就是右值引用。因为这个特性，所以叫通用引用。auto &amp;&amp;name也是一种通用引用。 前面所说的更低消耗的形参拷贝方式可以用通用引用的方式来实现。 12345678910111213class Server { public: template&lt;typename T&gt; Server(T &amp;&amp;s) : my_str_(std::forward&lt;T&gt;(s)) {} private: std::string my_str_;};std::string text(&quot;hhh&quot;);Server(text); // 传左值消耗：一次拷贝Server(std::move(text)); // 传右值消耗：一次移动Server(&quot;hello&quot;); // 传右值消耗：转发&quot;hello&quot;到my_str_的构造行数中，没有移动/拷贝操作 通用引用的方式有一个问题，因为什么参数都能够传给通用引用，所以通用引用往往会匹配比你认为的更多范围的类型，这种行为有时候会导致奇怪的报错，尤其在考虑继承的情况下。 个人习惯是少用这种实现方式，很难排查，尤其是模板编程，编译器往往会给出诡异的错误信息。","link":"/2022/02/22/%E5%87%BD%E6%95%B0%E5%BD%A2%E5%8F%82%E5%AE%9A%E4%B9%89%E4%B9%A0%E6%83%AF/"}],"tags":[],"categories":[]}